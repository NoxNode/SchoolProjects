#include "../Headers/ChildThread.h"

ChildThread::ChildThread(Instruction* p_instruction) :
instruction(p_instruction)
{}

void* ChildThread::threadMainBody (void* arg) {
    // get the THREAD_BEGIN instruction
	Instruction* newThreadInstruction = (Instruction*)(((ChildThread*)arg)->getInstruction());
    // get the index of the first instruction to execute from the parameters
	unsigned int startIndex = (unsigned int)((*newThreadInstruction->getParameters())[4]->getValue<NUMERIC>());
    // get the index of the last instruction to execute from the parameters
	unsigned int endIndex = (unsigned int)((*newThreadInstruction->getParameters())[3]->getValue<NUMERIC>());
	// loop from startIndex to endIndex - 1
		// -1 because endIndex is the index of the instruction after the THREAD_END instruction
	for(unsigned int i = startIndex; i < endIndex - 1; i++) {
        // get the current instruction
		Instruction* instruction = (*newThreadInstruction->getProgram()->getInstructions())[i];
		try {
            instruction->execute(); // execute the instruction
            if(instruction->getJMPFlag() == true) { // if the jump flag is set
				// set the index to the instruction's first parameter (the instruction index of the specified label)
				// although need to -1 because it will be incremented on the next iteration of this loop
                i = (unsigned int)((*instruction->getParameters())[3]->getValue<NUMERIC>() - 1);
                instruction->setJMPFlag(false); // set jump flag to false
            }
        }
        catch(Error& err) { // catch and output any errors generated by the instruction at runtime
			err.errorCode = instruction->getLineNumber();
            err.outToBuffer((*instruction->getProgram()->getErrBuffer()), instruction->getProgram()->getErrBufferMutex());
            return NULL; // return because we don't want to keep running if there's a runtime error
        }
	}
    return NULL;
}

Instruction* ChildThread::getInstruction() {
    return instruction;
}

ChildThread::~ChildThread() {}
